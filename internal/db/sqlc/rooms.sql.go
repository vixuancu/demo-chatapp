// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rooms.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createRoom = `-- name: CreateRoom :one
INSERT INTO
    rooms (
        room_code,
        room_name,
        room_is_direct_chat,
        room_created_by
    )
VALUES ($1, $2, $3, $4) RETURNING room_id, room_code, room_name, room_is_direct_chat, room_created_by, room_created_at, room_updated_at
`

type CreateRoomParams struct {
	RoomCode         string    `json:"room_code"`
	RoomName         *string   `json:"room_name"`
	RoomIsDirectChat bool      `json:"room_is_direct_chat"`
	RoomCreatedBy    uuid.UUID `json:"room_created_by"`
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (Room, error) {
	row := q.db.QueryRow(ctx, createRoom,
		arg.RoomCode,
		arg.RoomName,
		arg.RoomIsDirectChat,
		arg.RoomCreatedBy,
	)
	var i Room
	err := row.Scan(
		&i.RoomID,
		&i.RoomCode,
		&i.RoomName,
		&i.RoomIsDirectChat,
		&i.RoomCreatedBy,
		&i.RoomCreatedAt,
		&i.RoomUpdatedAt,
	)
	return i, err
}

const deleteRoom = `-- name: DeleteRoom :exec
DELETE FROM rooms WHERE room_id = $1
`

func (q *Queries) DeleteRoom(ctx context.Context, roomID int64) error {
	_, err := q.db.Exec(ctx, deleteRoom, roomID)
	return err
}

const generateUniqueRoomCode = `-- name: GenerateUniqueRoomCode :one
WITH random_code AS (
    SELECT array_to_string(ARRAY(SELECT chr((65 + round(random() * 25))::integer) 
    FROM generate_series(1, 6)), '') AS code
)
SELECT code FROM random_code
WHERE NOT EXISTS (SELECT 1 FROM rooms WHERE room_code = code)
`

func (q *Queries) GenerateUniqueRoomCode(ctx context.Context) (string, error) {
	row := q.db.QueryRow(ctx, generateUniqueRoomCode)
	var code string
	err := row.Scan(&code)
	return code, err
}

const getAllRoomsWithMemberCount = `-- name: GetAllRoomsWithMemberCount :many
SELECT r.room_id, r.room_code, r.room_name, r.room_is_direct_chat, r.room_created_by, r.room_created_at, r.room_updated_at, COUNT(rm.user_uuid) as member_count
FROM rooms r
    LEFT JOIN room_members rm ON r.room_id = rm.room_id
GROUP BY
    r.room_id
ORDER BY r.room_created_at DESC
LIMIT $1
OFFSET
    $2
`

type GetAllRoomsWithMemberCountParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllRoomsWithMemberCountRow struct {
	RoomID           int64     `json:"room_id"`
	RoomCode         string    `json:"room_code"`
	RoomName         *string   `json:"room_name"`
	RoomIsDirectChat bool      `json:"room_is_direct_chat"`
	RoomCreatedBy    uuid.UUID `json:"room_created_by"`
	RoomCreatedAt    time.Time `json:"room_created_at"`
	RoomUpdatedAt    time.Time `json:"room_updated_at"`
	MemberCount      int64     `json:"member_count"`
}

func (q *Queries) GetAllRoomsWithMemberCount(ctx context.Context, arg GetAllRoomsWithMemberCountParams) ([]GetAllRoomsWithMemberCountRow, error) {
	rows, err := q.db.Query(ctx, getAllRoomsWithMemberCount, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllRoomsWithMemberCountRow{}
	for rows.Next() {
		var i GetAllRoomsWithMemberCountRow
		if err := rows.Scan(
			&i.RoomID,
			&i.RoomCode,
			&i.RoomName,
			&i.RoomIsDirectChat,
			&i.RoomCreatedBy,
			&i.RoomCreatedAt,
			&i.RoomUpdatedAt,
			&i.MemberCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomByCode = `-- name: GetRoomByCode :one
SELECT room_id, room_code, room_name, room_is_direct_chat, room_created_by, room_created_at, room_updated_at FROM rooms WHERE room_code = $1
`

func (q *Queries) GetRoomByCode(ctx context.Context, roomCode string) (Room, error) {
	row := q.db.QueryRow(ctx, getRoomByCode, roomCode)
	var i Room
	err := row.Scan(
		&i.RoomID,
		&i.RoomCode,
		&i.RoomName,
		&i.RoomIsDirectChat,
		&i.RoomCreatedBy,
		&i.RoomCreatedAt,
		&i.RoomUpdatedAt,
	)
	return i, err
}

const getRoomByID = `-- name: GetRoomByID :one
SELECT room_id, room_code, room_name, room_is_direct_chat, room_created_by, room_created_at, room_updated_at FROM rooms WHERE room_id = $1
`

func (q *Queries) GetRoomByID(ctx context.Context, roomID int64) (Room, error) {
	row := q.db.QueryRow(ctx, getRoomByID, roomID)
	var i Room
	err := row.Scan(
		&i.RoomID,
		&i.RoomCode,
		&i.RoomName,
		&i.RoomIsDirectChat,
		&i.RoomCreatedBy,
		&i.RoomCreatedAt,
		&i.RoomUpdatedAt,
	)
	return i, err
}

const getRoomMembers = `-- name: GetRoomMembers :many
SELECT u.user_uuid, u.user_email, u.user_password, u.user_fullname, u.user_role, u.user_created_at, u.user_updated_at
FROM users u
    JOIN room_members rm ON u.user_uuid = rm.user_uuid
WHERE
    rm.room_id = $1
`

func (q *Queries) GetRoomMembers(ctx context.Context, roomID int64) ([]User, error) {
	rows, err := q.db.Query(ctx, getRoomMembers, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserUuid,
			&i.UserEmail,
			&i.UserPassword,
			&i.UserFullname,
			&i.UserRole,
			&i.UserCreatedAt,
			&i.UserUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserMemberOfRoom = `-- name: IsUserMemberOfRoom :one
SELECT EXISTS (
        SELECT 1
        FROM room_members
        WHERE
            user_uuid = $1
            AND room_id = $2
    ) AS is_member
`

type IsUserMemberOfRoomParams struct {
	UserUuid uuid.UUID `json:"user_uuid"`
	RoomID   int64     `json:"room_id"`
}

func (q *Queries) IsUserMemberOfRoom(ctx context.Context, arg IsUserMemberOfRoomParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserMemberOfRoom, arg.UserUuid, arg.RoomID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}

const joinRoom = `-- name: JoinRoom :one
INSERT INTO
    room_members (user_uuid, room_id)
VALUES ($1, $2) RETURNING user_uuid, room_id, member_role, room_member_created_at, room_member_updated_at
`

type JoinRoomParams struct {
	UserUuid uuid.UUID `json:"user_uuid"`
	RoomID   int64     `json:"room_id"`
}

func (q *Queries) JoinRoom(ctx context.Context, arg JoinRoomParams) (RoomMember, error) {
	row := q.db.QueryRow(ctx, joinRoom, arg.UserUuid, arg.RoomID)
	var i RoomMember
	err := row.Scan(
		&i.UserUuid,
		&i.RoomID,
		&i.MemberRole,
		&i.RoomMemberCreatedAt,
		&i.RoomMemberUpdatedAt,
	)
	return i, err
}

const leaveRoom = `-- name: LeaveRoom :exec
DELETE FROM room_members 
WHERE user_uuid = $1 AND room_id = $2
`

type LeaveRoomParams struct {
	UserUuid uuid.UUID `json:"user_uuid"`
	RoomID   int64     `json:"room_id"`
}

func (q *Queries) LeaveRoom(ctx context.Context, arg LeaveRoomParams) error {
	_, err := q.db.Exec(ctx, leaveRoom, arg.UserUuid, arg.RoomID)
	return err
}

const listUserRooms = `-- name: ListUserRooms :many
SELECT r.room_id, r.room_code, r.room_name, r.room_is_direct_chat, r.room_created_by, r.room_created_at, r.room_updated_at
FROM rooms r
    JOIN room_members rm ON r.room_id = rm.room_id
WHERE
    rm.user_uuid = $1
ORDER BY r.room_updated_at DESC
`

func (q *Queries) ListUserRooms(ctx context.Context, userUuid uuid.UUID) ([]Room, error) {
	rows, err := q.db.Query(ctx, listUserRooms, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Room{}
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.RoomID,
			&i.RoomCode,
			&i.RoomName,
			&i.RoomIsDirectChat,
			&i.RoomCreatedBy,
			&i.RoomCreatedAt,
			&i.RoomUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserRoomsWithLastMessage = `-- name: ListUserRoomsWithLastMessage :many
SELECT 
    r.room_id,
    r.room_code,
    r.room_name,
    r.room_is_direct_chat,
    r.room_created_by,
    r.room_created_at,
    r.room_updated_at,
    -- Last message info with COALESCE to handle NULL
    COALESCE(lm.message_id, 0) as last_message_id,
    COALESCE(lm.content, '') as last_message_content,
    COALESCE(lm.message_created_at, r.room_created_at) as last_message_time,
    COALESCE(lm.user_uuid, '00000000-0000-0000-0000-000000000000'::uuid) as last_sender_uuid,
    u.user_fullname as last_sender_name
FROM rooms r
INNER JOIN room_members rm ON r.room_id = rm.room_id
LEFT JOIN LATERAL (
    SELECT m.message_id, m.content, m.message_created_at, m.user_uuid
    FROM messages m 
    WHERE m.room_id = r.room_id 
    ORDER BY m.message_created_at DESC 
    LIMIT 1
) lm ON true
LEFT JOIN users u ON lm.user_uuid = u.user_uuid
WHERE rm.user_uuid = $1
ORDER BY COALESCE(lm.message_created_at, r.room_created_at) DESC
`

type ListUserRoomsWithLastMessageRow struct {
	RoomID             int64     `json:"room_id"`
	RoomCode           string    `json:"room_code"`
	RoomName           *string   `json:"room_name"`
	RoomIsDirectChat   bool      `json:"room_is_direct_chat"`
	RoomCreatedBy      uuid.UUID `json:"room_created_by"`
	RoomCreatedAt      time.Time `json:"room_created_at"`
	RoomUpdatedAt      time.Time `json:"room_updated_at"`
	LastMessageID      int64     `json:"last_message_id"`
	LastMessageContent string    `json:"last_message_content"`
	LastMessageTime    time.Time `json:"last_message_time"`
	LastSenderUuid     uuid.UUID `json:"last_sender_uuid"`
	LastSenderName     *string   `json:"last_sender_name"`
}

func (q *Queries) ListUserRoomsWithLastMessage(ctx context.Context, userUuid uuid.UUID) ([]ListUserRoomsWithLastMessageRow, error) {
	rows, err := q.db.Query(ctx, listUserRoomsWithLastMessage, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserRoomsWithLastMessageRow{}
	for rows.Next() {
		var i ListUserRoomsWithLastMessageRow
		if err := rows.Scan(
			&i.RoomID,
			&i.RoomCode,
			&i.RoomName,
			&i.RoomIsDirectChat,
			&i.RoomCreatedBy,
			&i.RoomCreatedAt,
			&i.RoomUpdatedAt,
			&i.LastMessageID,
			&i.LastMessageContent,
			&i.LastMessageTime,
			&i.LastSenderUuid,
			&i.LastSenderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
